# Community Detection with Louvain Algorithm (Python Implementation)

This project is an improved Python implementation of a community detection algorithm inspired by Louvainâ€™s method. It is designed for analyzing large undirected graphs by optimizing a metric that combines modularity and a regularization term.

## Overview

The algorithm follows these key steps:

1. **Initialization**  
   - The graph is loaded from an input file where each line contains two integers (`src dst`) representing an edge.
   - An initial graph is built as an adjacency list (with sorted neighbors) for fast lookup.

2. **Phase 1: Modularity Optimization**  
   - Vertices are iteratively moved between communities in a randomized order.
   - The change in modularity is calculated and moves that improve modularity are accepted.
   - A limit on the maximum number of steps can be enforced to avoid over-merging communities.

3. **Phase 2: Graph Aggregation**  
   - Once no more moves improve modularity, communities are aggregated to form a new graph.
   - Each node in the new graph represents a community from the previous phase.

4. **Multiple Repetitions and Best Partition Selection**  
   - The entire process is repeated a fixed number of times (REPS) to overcome local optima.
   - The best partition is selected based on the metric:  
     **Q = modularity + regularization**

## Files

- **main.py**: The main Python code implementing the algorithm.
- **partition.graph**: The output file generated by the program, containing the best partition.
  - Each line in this file represents a community and lists the vertices belonging to it.
- **README.md**: This file, containing an overview and instructions.

## Requirements

- Python 3.x

No external libraries are required beyond the Python standard library.

## Usage

1. **Compile/Run**  
   Ensure the script is executable or run it with Python directly:
   ```bash
   python main.py <path_to_graph_file>
Example:

bash
Copy
python main.py tests/1.graph
Input Format
The input file should list one edge per line with two space-separated integers:

css
Copy
src dst
Output

The algorithm prints the best Q value (modularity + regularization) to the standard output.

The final partition is saved in a file named partition.graph.

Algorithm Improvements
Readability & Structure: The code is refactored into clear classes and functions with detailed comments.

Randomized Vertex Ordering: Random shuffling is used to escape local optima.

Modularity & Regularization: The combined metric helps prevent over-merging of communities.

Multiple Iterations: The process is repeated several times (REPS) to yield robust community detection results.

Future Enhancements
Performance: Further optimizations can be made by using vectorized operations (e.g., with NumPy) if needed.

Parameter Tuning: Experiment with different values for REPS and MAX_STEPS for various graph types.

Additional Metrics: Incorporate more sophisticated heuristics or metrics for different graph densities.

